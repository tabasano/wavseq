#!/usr/bin/ruby
# -*- encoding: utf-8 -*-
require 'kconv'
require 'optparse'
require './lib/msm'

def hint
  cmd=File.basename($0)
  puts <<EOF
usage: #{cmd} -d \"dddd dr3 dddd r4 drdrdrdr dddd dr3\" -o outfile.mid -t bpm
       #{cmd} -i infile.txt  -o outfile.mid -t bpm

EOF
end

infile=false
outfile=false
expfile=false
vfuzzy=2
$debuglevel=1
data=""
pspl="///"
cmark=";;"
bpm=120
octaveMode=:near
opt = OptionParser.new
opt.on('-i file',"input file") {|v| infile=v }
opt.on('-o file',"output file") {|v| outfile=v }
opt.on('-e file',"write down macro etc. expanded data") {|v| expfile=v }
opt.on('-d d',"input data string") {|v|
  data=v
  STDERR.puts data if $DEBUG
}
opt.on('-D',"debug") {|v| $DEBUG=v }
opt.on('-s',"show syntax") {|v|
  hint
  exit
}
opt.on('-t b',"bpm") {|v| bpm=v.to_f }
opt.on('-T w',"programChange test like instrument name '...'") {|v| $test=v }
opt.on('-c d',"cycle data for test mode") {|v| $testdata=v }
opt.on('-C d',"comment mark") {|v| cmark=v; puts "comment mark is '#{cmark}'" }
opt.on('-p pspl',"page split chars") {|v| pspl=v }
opt.on('-F i',"fuzzy shift mode") {|v| $fuzzy=v.to_i }
opt.on('-v i',"velocity fuzzy value [default 2]") {|v| vfuzzy=v.to_i }
opt.on('-O',"octave legacy mode") {|v| octaveMode=:far }
opt.on('-I',"ignore roland check sum") {|v| $ignoreChecksum=v }
opt.on('-M i',"debug level") {|v| $debuglevel=v.to_i }
opt.on('-m i',"mode of test/ 1:GM 2:XG 3:GS") {|v| $testmode=v.to_i }
opt.on('-n',"test only (dont write outfile)") {|v| $testonly=true }
opt.parse!(ARGV)
String.new.setcmark(cmark)


title,midifilename=name2title(infile)
data=File.read(infile).trim(" ;") if infile && File.exist?(infile)
outfile=midifilename if ! outfile

(hint;midihint;exit) if (! data || ! outfile ) && ! $test

data=data.toutf8

tbase=480 # division
delta=varlenHex(tbase)
mx=MidiHex
mx.prepare(tbase,0x40,octaveMode,vfuzzy)
data=mx.test($testdata,$testmode) if $test

thisVer=File.mtime($0).strftime("%Y-%m-%d")
thisVer="" if $debuglevel>1
comment="generated by midi-simple-make.rb (#{thisVer})"
commenthex,len=txt2hex(comment)
d_comment="# #{comment}\n#{delta} #{mx.metaText(commenthex)}"
d_title=""
if title
  commenthex,len=txt2hex(title)
  zerodelta=varlenHex(0)
  d_title="# title '#{title}'\n#{zerodelta} #{mx.metaTitle(commenthex)}"
end
comment="data end"
commenthex,len=txt2hex(comment)
d_last="# #{comment}\n#{delta} #{mx.metaText(commenthex)}"
if $fuzzy && (tbase/$fuzzy<8)
  STDERR.puts "really?#{"?"*(8*$fuzzy/tbase)}"
end
rundatas=[]
rawdatas=[]
macro={}
tracks=data.tracks(pspl)
fuzz=unirand($fuzzy,tracks.size) if $fuzzy
p tracks if $DEBUG && $debuglevel>1
tracks.map{|track|
    m,track=macroDef(track)
    macro.merge!(m)
    track=modifierComp(track,macro)
    repCalc(track,macro,tbase)
  }.each{|t|
    r=loadCalc(t)
    if $fuzzy
      n=fuzz.shift
      STDERR.puts "track shift: #{n} tick#{n>1 ? 's' : ''}"
      pre="r*#{n} "
    else
      pre=""
    end
    case r[0]
    when :raw
      rawdatas<<r[1]
    when :seq
      rundatas<<pre+r[1]
    end
}
p macro if$DEBUG
rawdatas.flatten!
open(expfile,"w"){|f|f.puts rundatas*"|||"} if expfile
tracknum=rawdatas.size+rundatas.size
tracknum=tracks.size
format=1

d_header=mx.header(format,tracknum,tbase) 
tracks=[]
# remember starting position check if data exist before sound
tc=0
tracks<< d_title + d_comment + mx.tempo(bpm).data + mx.makefraze(rundatas[0],tc) + d_last
rundatas[1..-1].each{|track|
  tc+=1
  tracks<< mx.restHex + mx.makefraze(track,tc) + d_last
}
alla=[d_header]+tracks.map{|t|mx.trackMake(t)}.flatten
puts alla if $DEBUG
all=alla.map{|i|i.trim("","#")}*""
array=[all.split.join]
#puts alla,all,array
binary = array.pack( "H*" )

# save data. data = MIDI-header + seq-made MIDI-tracks + loaded extra MIDI-tracks.
if $testonly
  exit
elsif outfile==""
  print binary
  rawdatas.each{|i|
    print i
  }
else
  open(outfile,"wb"){|f|
    f.write binary
    rawdatas.each{|i|
      f.write i
    }
  }
end
